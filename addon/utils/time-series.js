/**
 * Contains typedefs, constants and functions related to time series.
 *
 * @author Michał Borzęcki
 * @copyright (C) 2022 ACK CYFRONET AGH
 * @license This software is released under the MIT license cited in 'LICENSE.txt'.
 */

/**
 * # TIME SERIES
 *
 * ## WHAT ARE TIME SERIES
 *
 * Time series mechanism allows to aggregate statistics over time and serve
 * it's content to a user via API. Time series are defined using a schema
 * `TimeSeriesCollectionSchema`.
 *
 * ## WHAT ARE TIME SERIES ELEMENTS
 *
 * Time series concept is a multilevel structure:
 * 1. System can contain many "time series collections".
 * 2. Each time series collection can contain many "time series".
 * 3. Each time series can contain many "metrics".
 *
 * The main element is a single "time series". Time series represents a single
 * measurable property which changes over time. Examples: read speed per second,
 * directory size, number of files in a space. Every time series has it's
 * own name and unit (like bytes per second, percentage etc.).
 *
 * Metrics are used to describe how data should be aggregated inside each time
 * series and produces so called "windows". Each window is like a point in a
 * chart - has a value and a timestamp. To produce these windows metric uses
 * properties like:
 * - aggregator - like `sum` to sum all incoming measurements into a single
 *   value, or `max` to take only the biggest one.
 * - resolution - how big in time should be each window (point). Like 3600
 *   to have a 1-hour-wide window
 * - retention - how many windows should be remembered. In case of reaching the
 *   retention limit, the oldest windows are deleted.
 * Time series can contain many metrics with different combination of above
 * properties. It's a very common approach to have some metrics repeated with
 * different resolution property.
 *
 * Time series collection is a way to group together related time series. It also
 * allows to *generate* new time series on-the-fly.
 *
 * ## HOW COLLECTION GENERATES TIME SERIES
 *
 * Time series collection is a factory, which can generate time series using two
 * strategies: `exact` and `addPrefix`.
 *
 * `exact` generation type allows to generate only single time series with
 * specific settings (including name). If you want only one instance of a specific
 * time series, it's the best choice.
 *
 * `addPrefix` generation type creates new time series on-demand, each of which
 * has the same properties except name. Name is generated by adding some dynamic
 * and unique string to a constant prefix (hence name "addPrefix"). For example
 * a time series schema shown below:
 * ```
 * {
 *   nameGeneratorType: 'addPrefix',
 *   nameGenerator: 'storage-',
 *   unit: 'bytes',
 *   metrics: [{
 *     aggregator: 'sum',
 *     resolution: 3600,
 *     retention: 24,
 *   }],
 * },
 * ```
 * tells time series collection that there might be a dynamic number of time series
 * with names in format "storage-[here_some_random_part]" and the same `unit` and
 * `metrics`. If you want to have separate (but the same) time series describing
 * some variable number of entities (like separate time series for each storage), then
 * `addPrefix` is the best choice.
 */

import _ from 'lodash';

const i18nPrefix = 'utils.timeSeries';

/**
 * @typedef {Object} TimeSeriesCollectionSchema
 * @property {Array<TimeSeriesSchema>} timeSeriesSchemas
 */

/**
 * @typedef {Object} TimeSeriesSchema
 * It's a recipe used for time series generation (done by time series collection).
 * @property {TimeSeriesNameGeneratorType} nameGeneratorType specifies method
 * of time series generation
 * @property {string} nameGenerator base name to be used by name generator type
 * @property {TimeSeriesUnit} unit time series values unit
 * @property {Object<string, TimeSeriesMetric>} metrics keys are metric names.
 * Describes how incoming measurements should be aggregated into time windows.
 */

/**
 * @typedef {'exact'|'addPrefix'} TimeSeriesNameGeneratorType
 * `exact` uses `nameGenerator` in `TimeSeriesSchema` as a full time series name
 * (so only one time series can be created using that generator.)
 * `addPrefix` places `nameGenerator` at the beginning of each generated time
 * series' name (so it is possible to generate many time series with different names).
 */

/**
 * @type {Array<TimeSeriesNameGeneratorType>}
 */
export const timeSeriesNameGeneratorTypes = [
  'exact',
  'addPrefix',
];

/**
 * @param {Ember.Service} i18n
 * @param {TimeSeriesNameGeneratorType} timeSeriesNameGeneratorType
 * @returns {SafeString}
 */
export function translateTimeSeriesNameGeneratorType(i18n, timeSeriesNameGeneratorType) {
  const i18nPath = `${i18nPrefix}.timeSeriesNameGeneratorTypes.${timeSeriesNameGeneratorType}`;
  return i18n.t(i18nPath, {}, { defaultValue: '' });
}

/**
 * @typedef {TimeSeriesStandardUnit | TimeSeriesCustomUnit} TimeSeriesUnit
 */

/**
 * @typedef {
 *   'none' |
 *   'milliseconds' |
 *   'seconds' |
 *   'bits' |
 *   'bytes' |
 *   'hertz' |
 *   'countsPerSec' |
 *   'bitsPerSec' |
 *   'bytesPerSec' |
 *   'operationsPerSec' |
 *   'requestsPerSec' |
 *   'readsPerSec' |
 *   'writesPerSec' |
 *   'ioOperationsPerSec' |
 *   'percent' |
 *   'percentNormalized' |
 *   'boolean'
 * } TimeSeriesStandardUnit
 */

/**
 * @type {Array<TimeSeriesUnit>}
 */
export const timeSeriesStandardUnits = [
  'none',
  'milliseconds',
  'seconds',
  'bits',
  'bytes',
  'hertz',
  'countsPerSec',
  'bitsPerSec',
  'bytesPerSec',
  'operationsPerSec',
  'requestsPerSec',
  'readsPerSec',
  'writesPerSec',
  'ioOperationsPerSec',
  'percent',
  'percentNormalized',
  'boolean',
];

/**
 * @param {Ember.Service} i18n
 * @param {TimeSeriesStandardUnit} timeSeriesStandardUnit
 * @returns {SafeString}
 */
export function translateTimeSeriesStandardUnit(i18n, timeSeriesStandardUnit) {
  const i18nPath = `${i18nPrefix}.timeSeriesStandardUnits.${timeSeriesStandardUnit}`;
  return i18n.t(i18nPath, {}, { defaultValue: '' });
}

/**
 * @typedef {`custom:${string}`} TimeSeriesCustomUnit
 */

/**
 * When the custom unit is received/saved, it is prefixed with `custom:`
 * (e.g. `custom:my_own_unit123`). That prefix allows to recognize which unit
 * is a built-in one and which is custom.
 * @type {string}
 */
export const timeSeriesCustomUnitPrefix = 'custom:';

/**
 * @typedef {Object} TimeSeriesMetric
 * Describes how measurements should be aggregated into time windows.
 * @property {TimeSeriesMetricAggregator} aggregator aggregation function (how
 * different measurement values should be joined)
 * @property {TimeSeriesMetricResolution} resolution time span of each window
 * @property {number} retention limit of how many windows should be persisted
 */

/**
 * @typedef {'sum'|'max'|'min'|'first'|'last'} TimeSeriesMetricAggregator
 */

/**
 * @type {Array<TimeSeriesMetricAggregator>}
 */
export const timeSeriesMetricAggregators = [
  'sum',
  'max',
  'min',
  'first',
  'last',
];

/**
 * @param {Ember.Service} i18n
 * @param {TimeSeriesMetricAggregator} timeSeriesMetricAggregator
 * @param {{ short: boolean }} options
 * @returns {SafeString}
 */
export function translateTimeSeriesMetricAggregator(
  i18n,
  timeSeriesMetricAggregator, { short = false } = {}
) {
  const i18nPath =
    `${i18nPrefix}.timeSeriesMetricAggregators.${short ? 'short' : 'standard'}.${timeSeriesMetricAggregator}`;
  return i18n.t(i18nPath, {}, { defaultValue: '' });
}

/**
 * @typedef {5|60|3600|86400|604800|2592000|31536000|0} TimeSeriesMetricResolution
 * Values represents: 5 seconds, 1 minute, 1 hour, 1 day, 1 week, 1 month,
 * 1 year, infinity.
 */

/**
 * @type {Object<string, TimeSeriesMetricResolution>}
 */
export const timeSeriesMetricResolutionsMap = {
  fiveSeconds: 5,
  minute: 60,
  hour: 60 * 60,
  day: 24 * 60 * 60,
  week: 7 * 24 * 60 * 60,
  month: 30 * 24 * 60 * 60,
  year: 365 * 24 * 60 * 60,
  infinity: 0,
};

/**
 * @type {Array<TimeSeriesMetricResolution>}
 */
export const timeSeriesMetricResolutions = [
  timeSeriesMetricResolutionsMap.fiveSeconds,
  timeSeriesMetricResolutionsMap.minute,
  timeSeriesMetricResolutionsMap.hour,
  timeSeriesMetricResolutionsMap.day,
  timeSeriesMetricResolutionsMap.week,
  timeSeriesMetricResolutionsMap.month,
  timeSeriesMetricResolutionsMap.year,
  timeSeriesMetricResolutionsMap.infinity,
];

/**
 * @type {Object<TimeSeriesMetricResolution, string>}
 */
const invertedTimeSeriesMetricResolutionsMap = _.invert(timeSeriesMetricResolutionsMap);

/**
 * @param {Ember.Service} i18n
 * @param {TimeSeriesMetricResolution} timeSeriesMetricResolution
 * @param {{ short: boolean }} options
 * @returns {SafeString}
 */
export function translateTimeSeriesMetricResolution(
  i18n,
  timeSeriesMetricResolution, { short = false } = {}
) {
  const timeSeriesMetricResolutionName =
    invertedTimeSeriesMetricResolutionsMap[timeSeriesMetricResolution];
  const i18nPath = timeSeriesMetricResolutionName &&
    `${i18nPrefix}.timeSeriesMetricResolutions.${short ? 'short' : 'standard'}.${timeSeriesMetricResolutionName}`;
  return i18nPath ? i18n.t(i18nPath, {}, { defaultValue: '' }) : '';
}

/**
 * @param {TimeSeriesSchema} timeSeriesSchema
 * @param {TimeSeriesMetricAggregator} aggregator
 * @param {{ allowInfinityResolution: boolean }} [options]
 * @returns {Array<string>}
 */
export function getTimeSeriesMetricNamesWithAggregator(
  timeSeriesSchema, aggregator, { allowInfinityResolution = false } = {}
) {
  const metrics = timeSeriesSchema?.metrics ?? {};
  return Object.keys(metrics)
    .filter((metricName) =>
      metrics[metricName]?.aggregator === aggregator && (
        metrics[metricName]?.resolution || allowInfinityResolution
      )
    )
    .sort((m1, m2) => {
      if (!metrics[m1].resolution) {
        return 1;
      } else if (!metrics[m2].resolution) {
        return -1;
      } else {
        return metrics[m1].resolution - metrics[m2].resolution;
      }
    });
}

/**
 * @typedef {Object<string, Array<string>} TimeSeriesCollectionLayout
 * It's a map (seriesName -> (array of metric names)). Can be used to pass
 * information about collection current time series or describe which time windows
 * you would like to fetch from collection.
 */

/**
 * @typedef {Object} TimeSeriesCollectionSliceQueryParams
 * @property {TimeSeriesCollectionLayout} layout
 * @property {number|null} [startTimestamp] timestamp of the newest point you want
 * to receive
 * @property {number} [windowLimit]
 */

/**
 * @typedef {Object<string, Object<string, Array<TimeSeriesWindow>>} TimeSeriesCollectionSlice
 *   is a nested map (seriesName -> (metricName -> array of windows))
 */

/**
 * @typedef {Object} TimeSeriesWindow
 * @property {number} timestamp
 * @property {number} value
 */
